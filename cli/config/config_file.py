from configparser import ConfigParser
from pathlib import Path
from typing import Dict, Tuple, List, Any, TYPE_CHECKING

from cli.util.hash import hash_file

if TYPE_CHECKING:
    from _typeshed import SupportsWrite


class TIMConfig(ConfigParser):
    """
    TIM configuration file handler.
    """

    def __init__(self, save_path: str, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self._comment_lines: Dict[Tuple[str, str], str] = {}
        self._save_path = save_path

    def add_comment(self, section: str, option: str, comment: str) -> None:
        self._comment_lines[(section, option)] = comment.strip()

    def load_ext_dict(self, ext_dict: Dict[str, Dict[str, Tuple[str, str]]]) -> None:
        for section, options in ext_dict.items():
            self.add_section(section)
            for key, (value, comment) in options.items():
                self.set(section, key, value)
                self.add_comment(section, key, comment)

    def save(self) -> None:
        with open(self._save_path, "w") as fp:
            self.write(fp)

    def env_dict(self) -> Dict[str, str]:
        env_dict = {}
        for section in self._sections:  # type: ignore
            if section == "__meta__":
                continue
            for key in self._sections[section].keys():  # type: ignore
                env_dict["{}_{}".format(section.upper(), key.upper())] = self.get(
                    section, key
                )

        # Generate some additional variable autogenerated by TIM
        cwd = Path.cwd()
        env_dict["TIM_IMAGE_TAG"] = hash_file(
            cwd / "timApp" / "Dockerfile", cwd / "poetry.toml"
        )
        env_dict["TIM_ROOT"] = cwd.as_posix()
        return env_dict

    def write(
        self, fp: "SupportsWrite[str]", space_around_delimiters: bool = True
    ) -> None:
        if space_around_delimiters:
            d = " {} ".format(self._delimiters[0])  # type: ignore
        else:
            d = self._delimiters[0]  # type: ignore
        # Ensure meta is always written first
        meta_section = self._sections.get("__meta__")  # type: ignore
        if meta_section:
            self._write_section(fp, "__meta__", meta_section.items(), d)
        for section in self._sections:  # type: ignore
            if section == "__meta__":
                continue
            self._write_section(fp, section, self._sections[section].items(), d)  # type: ignore

    def _write_section(
        self,
        fp: "SupportsWrite[str]",
        section_name: str,
        section_items: List[Tuple[str, str]],
        delimiter: str,
    ) -> None:
        fp.write("[{}]\n".format(section_name))
        for key, value in section_items:
            comment = self._comment_lines.get((section_name, key))
            if comment:
                for comment_line in comment.splitlines():
                    fp.write("{} {}\n".format(self._comment_prefixes[0], comment_line))  # type: ignore
            value = self._interpolation.before_write(self, section_name, key, value)  # type: ignore
            if value is not None or not self._allow_no_value:
                value = delimiter + str(value).replace("\n", "\n\t")
            else:
                value = ""
            fp.write("{}{}\n\n".format(key, value))
        fp.write("\n")
